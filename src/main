Hide TabsChats1 unread1
Calls
Stories
SettingsChatsNew chatMore Actions

Pinned
Note to Self
Sat
hi
Chats
Uboot
20m
Iason: #include <Servo.h> #include <Wire.h> #include "MS5837.h"  MS5837 sensor;  Servo AL, VRL, VRR, HRL, HRR, AR, VHR, HHR;             // Servo-Objekte f√ºr jeden ESC int ALPin = 24, VRLPin = 25, HRLPin = 27, ARPin = 29;  // Die Pins f√ºr AL, VRL, HRL, und AR int VHRPin = 26, HHRPin = 28;                         // Die Pins f√ºr VHR und HHR int rcsignalPin = 5;                                 // Der Pin, an dem das RC-Signal f√ºr AL und AR angeschlossen ist int rcsignalPin2 = 6;                               // Der Pin, an dem das RC-Signal f√ºr VHR und HHR angeschlossen ist int rcsignalPin3 = 7;                              // Der Pin, an dem das RC-Signal f√ºr VRL angeschlossen ist int rcsignalPin4 = 4;                             // Der Pin, an dem das RC-Signal f√ºr HRL angeschlossen ist   void setup() {      // Initialisiere die Relaispins als OUTPUT und schalte sie aus   pinMode(14, OUTPUT);   pinMode(15, OUTPUT);         // Auslass vorne   pinMode(16, OUTPUT);        // Auslass Hinten   pinMode(17, OUTPUT);       //Einlass Hinten   pinMode(18, OUTPUT);      // Haupteinlass    pinMode(19, OUTPUT);     // Einlass Vorne   pinMode(10, OUTPUT);    // Greifer ZU   pinMode(11, OUTPUT);   // Greifer AUF       AL.attach(ALPin);          // ESC an Pin 24 als AL   VRL.attach(VRLPin);       // ESC an Pin 25 als VRL   HRL.attach(HRLPin);      // ESC an Pin 27 als HRL   AR.attach(ARPin);       // ESC an Pin 29 als AR   VHR.attach(VHRPin);    // ESC an Pin 26 als VHR   HHR.attach(HHRPin);   // ESC an Pin 28 als HHR      Serial.begin(9600);   Serial.println("Starting");   Wire.begin();    while (!sensor.init()) {     Serial.println("Init failed!");     Serial.println("Are SDA/SCL connected correctly?");     Serial.println("Blue Robotics Bar30: White=SDA, Green=SCL");     Serial.println("\n\n\n");     }     sensor.setFluidDensity(997); // kg/m^3 (freshwater, 1029 for seawater)         digitalWrite(14, HIGH);            // Relais 14 ausschalten   digitalWrite(15, HIGH);           // Relais 15 ausschalten   digitalWrite(16, HIGH);          // Relais 16 ausschalten   digitalWrite(17, HIGH);         // Relais 17 ausschalten   digitalWrite(18, HIGH);        // Relais 18 ausschalten   digitalWrite(19, HIGH);       // Relais 19 ausschalten   digitalWrite(10, HIGH);      // Relais 20 ausschalten   digitalWrite(11, HIGH);     // Relais 21 ausschalten }     void loop() {    int rcSignal_AL_AR = pulseIn(rcsignalPin, HIGH, 25000);      // Lese das RC-Signal f√ºr AL und AR ein   int rcSignal_VHR_HHR = pulseIn(rcsignalPin2, HIGH, 25000);  // Lese das RC-Signal f√ºr VHR und HHR ein   int rcSignal_VRL = pulseIn(rcsignalPin3, HIGH, 25000);     // Lese das RC-Signal f√ºr VRL ein   int rcSignal_HRL = pulseIn(rcsignalPin4, HIGH, 25000);    // Lese das RC-Signal f√ºr HRL ein   int LPV;                                                  // abgespeicherter Druckwert, wenn die H√∂hensteuerung zuletzt bet√§tigt wurde   int differenzkleinAssistenz = 0.5 ;    // legt fest ab welcher differenz die hhr und vhr motoren angeschalten werden   int differenzgrossAssistenz = 1;       // legt fest ab welcher differenz die tauchzellen angeschalten werden - gross mit zwei s geschrieben da scharfes s nicht kompiliert     sensor.read();     if( rcSignal_VHR_HHR < 1200 && -1.25  > (sensor.depth())  ||  rcSignal_VHR_HHR > 1700  && -1  > (sensor.depth()) ){ // Wenn RC-Signal aktiv hoch oder runter  und Uboot mehr als 1 Meter Unterwasser   LPV = (sensor.depth()) ;                // sichere den aktuellen Druckwert als LPV (Last Pressure Value)     }          if (rcSignal_HRL >= 600 &&  rcSignal_HRL <= 1200) {    HRL.writeMicroseconds(1000);      } else if (rcSignal_HRL > 1800) {     HRL.writeMicroseconds(2000);   } else {     HRL.writeMicroseconds(1500);    }         if (rcSignal_AL_AR >= 900 && rcSignal_AL_AR <= 1300) {    // Steuere AL und AR basierend auf dem RC-Signal     AL.writeMicroseconds(1000);     AR.writeMicroseconds(1000);   } else if (rcSignal_AL_AR > 1800) {     AL.writeMicroseconds(2000);     AR.writeMicroseconds(2000);   } else {     AL.writeMicroseconds(1500);     AR.writeMicroseconds(1500);   }                                           if (rcSignal_VHR_HHR < 1200) {                            // Steuere VHR und HHR basierend auf dem RC-Signal     VHR.writeMicroseconds(1000);     HHR.writeMicroseconds(1000);   } else if (rcSignal_VHR_HHR > 1700) {     VHR.writeMicroseconds(2000);     HHR.writeMicroseconds(2000);   } else {     VHR.writeMicroseconds(1500);     HHR.writeMicroseconds(1500);   }     if (rcSignal_VRL >= 600 && rcSignal_VRL <= 1200) {    VRL.writeMicroseconds(1000);      } else if (rcSignal_VRL > 1700) {     VRL.writeMicroseconds(2000);   } else {     VRL.writeMicroseconds(1500);    }   int pulsewidths[6];    pulsewidths[4] = pulseIn(8, HIGH);      // Equipment    pulsewidths[5] = pulseIn(9, HIGH);     // Tauchzellen      int EquipmentValue = pulsewidths[4];   int TauchzellenValue = pulsewidths[5];       if (TauchzellenValue >= 700 && TauchzellenValue <= 1200) {           digitalWrite(15, LOW);        // Relais 15 einschalten Auslass Ventil Vorne           digitalWrite(16, LOW);       // Relais 16 einschalten Auslass Ventil hinten                } else if (TauchzellenValue >= 1400 && TauchzellenValue <= 1600) {                                                                                // Alle Relais zwischen 14 und 20 ausschalten           for (int i = 14; i <= 19; i++) {           digitalWrite(i, HIGH);           }           } else if (TauchzellenValue >= 1750 && TauchzellenValue <= 2000) {           digitalWrite(17, LOW);         // Relais 17 einschalten Einlass Ventil hinten            digitalWrite(18, LOW);        // Relais 18 einschalten Haupteinlass            digitalWrite(19, LOW);       // Relais 19 einschalten Einlass Ventil vorne                 } else {            // Alle Relais ausschalten, da die Pulsbreite von Kanal 6 nicht in den definierten Bereichen liegt              for (int i = 14; i <= 19; i++) {            digitalWrite(i, HIGH);             }              }              if (EquipmentValue >= 1000  ) {              digitalWrite(10, LOW);       // Relais 10 einschalten  Equipment               digitalWrite(11, HIGH);     // Relais 11 einschalten  Equipment                digitalWrite(18, LOW);    // Relais 18 einschalten Haupteinlass               } else {              digitalWrite(10, HIGH);      // Relais 11 ausschalten Equipment ge√§ndert auch 10 und 11-davor 21 20 wegen sda scl belegung               digitalWrite(11, LOW);      // Relais 11 ausschalten Equipment              digitalWrite(18, LOW);     // Relais 18 einschalten Haupteinlass          }       if (rcSignal_VHR_HHR < 1700  && rcSignal_VHR_HHR > 1200  &&( LPV + differenzkleinAssistenz ) >(sensor.depth()) ){                         VHR.writeMicroseconds(1000);     HHR.writeMicroseconds(1000);   } else if (rcSignal_VHR_HHR < 1700  && rcSignal_VHR_HHR > 1200  && ( LPV - differenzkleinAssistenz ) <(sensor.depth()) ) {     VHR.writeMicroseconds(2000);     HHR.writeMicroseconds(2000);   }   else {     VHR.writeMicroseconds(1500);     HHR.writeMicroseconds(1500);   } //-------------------------------------------------------------------------------------------------------------------      if (rcSignal_VHR_HHR < 1700  && rcSignal_VHR_HHR > 1200  &&( LPV + differenzgrossAssistenz ) >(sensor.depth()) ){                           digitalWrite(15, LOW);           // Relais 15 einschalten Auslass Ventil Vorne       digitalWrite(16, LOW);          // Relais 16 einschalten Auslass Ventil hinten       delay(1000);       digitalWrite(15, HIGH);           // Relais 15 ausschalten Auslass Ventil Vorne       digitalWrite(16, HIGH);          // Relais 16 ausschalten Auslass Ventil hinten          } else if (rcSignal_VHR_HHR < 1700  && rcSignal_VHR_HHR > 1200  && ( LPV - differenzgrossAssistenz ) <(sensor.depth()) ) {     digitalWrite(17, LOW);          // Relais 17 einschalten Einlass Ventil hinten      digitalWrite(18, LOW);         // Relais 18 einschalten Haupteinlass      digitalWrite(19, LOW);        // Relais 19 einschalten Einlass Ventil vorn     delay (1000);      digitalWrite(17, HIGH);          // Relais 17 ausschalten Einlass Ventil hinten      digitalWrite(18, HIGH);         // Relais 18 ausschalten Haupteinlass      digitalWrite(19, HIGH);        // Relais 19 ausschalten Einlass Ventil vorn   }   else {   digitalWrite(17, HIGH);              // Relais 17 einschalten Einlass Ventil hinten      digitalWrite(18, LOW);            // Relais 18 einschalten Haupteinlass      digitalWrite(19,  HIGH);         // Relais 19 einschalten Einlass Ventil vorne       digitalWrite(15,  HIGH);      // Relais 15 einschalten Auslass Ventil Vorne       digitalWrite(16,  HIGH);     // Relais 16 einschalten Auslass Ventil hinten   }            delay(1000 ); //nicht unter 1000 sonst laufen die motoren unkontroliert  }
M

Mama
13:05
Missed voice call
1

Nicole
10:25
My studio is in London. Have you ever been to London?
1
Miriam
2:44
Das Notebook ist kaputt. Der Bildschirm geht nicht mehr. Du hast es kaputt gemacht.
Popolozzi
Sat
Henriette: https://www.instagram.com/reel/C3kYALZNd19/?igsh=MWtudnFkOXlmM3U4Mw==
F

Friedemann
Sat
Ich komm jetzt
Papa
Sat
Missed voice call
Melle Eggersh
Sat
Outgoing voice call
Toni Smolka
Fri
dass So funktioniert
Kanalstr
Fri
Fernando: I got it thank you pascal!
Jana Schuetzenduebel
Fri
Wenn du krank bist, bring ihn doch wann anders, ich brauch ihn nicht
Vaideh Ziamahmoodi
Thu
üëç Danke, werde ich lesen ! Liebe Gr√º√üe zur√ºck ‚ù§Ô∏è
Alma
Thu
Bob
Deutschlaugust
Tue
Papa: üì∑ Ohoo, Kuschelpulli und den Mund voll. Das w√ºnschen sich viele! Bei uns sehen die pommes so aus.... Und die beiden essen mit!
Lenny Tretter
Mon
cool
Familie Pestalozzistrasse
Sun
Mama: Liebe Miriam, das kann ich machen. Ich habe allerdings am 13. um 10:00 Uhr ein Fotoshooting. Es Ich bin bis zum 14. nachmittags in M√ºnchen. Liebe Gr√º√üe Nonna
Brotretter
3 Mar
Kati: Ich komm gerade ausm Yoga. Bist du noch da?
J

Jack
2 Mar
Missed voice call
Iason
2 Mar
Wir haben jetzt am Donnerstag ein Gespr√§ch mit dem Schulleiter hier auch mit dem Hausmeister direkt- also wir k√∂nnen hier sicher testen,  ist jetzt blo√ü die Frage in welchem Umfang, aber ich habe als Optimalfall f√ºr uns mal geschrieben, dass so 4-6 Stunden an den Wochenenden bis Ende M√§rz und evt. noch an mehrere Tagen in den Ferien halt perfekt w√§re- mal schauen wie viel sie uns da geben, weniger reicht nat√ºrlich auch gut aus

Uboot

Today

Iason
Iason
/*
  SD card read/write

  This example shows how to read and write data to and from an SD card file
  The circuit:
   SD card attached to SPI bus as follows:
 ** MOSI - pin 11
 ** MISO - pin 12
 ** CLK - pin 13
 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN)

  created   Nov 2010
  by David A. Mellis
  modified 9 Apr 2012
  by Tom Igoe

  This example code is in the public domain.

*/

#include <SPI.h>
#include <SD.h>

File myFile;

void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  Serial.print("Initializing SD card...");

  if (!SD.begin(4)) {
    Serial.println("initialization failed!");
    while (1);
  }
  Serial.println("initialization done.");

  // open the file. note that only one file can be open at a time,
  // so you have to close this one before opening another.
  myFile = SD.open("test.txt", FILE_WRITE);

  // if the file opened okay, write to it:
  if (myFile) {
    Serial.print("Writing to test.txt...");
    myFile.println("testing 1, 2, 3.");
    // close the file:
    myFile.close();
    Serial.println("done.");
  } else {
    // if the file didn't open, print an error:
    Serial.println("error opening test.txt");
  }

  // re-open the file for reading:
  myFile = SD.open("test.txt");
  if (myFile) {
    Serial.println("test.txt:");

    // read from the file until there's nothing else in it:
    while (myFile.available()) {
      Serial.write(myFile.read());
    }
    // close the file:
    myFile.close();
  } else {
    // if the file didn't open, print an error:
    Serial.println("error opening test.txt");
  }
}

void loop() {
  // nothing happens after setup
}

Habe nur noch das hier gefunden, das ist aberauch nur ein beispiel f√ºrs schreiben auf das SD modul - ich suche sp√§ter nochmal
16:01

Iason
#include <SPI.h>
#include <SD.h>

#define CS 8


int sensorValue = analogRead(A0);
int i = 0;
File logFile;
unsigned long currentTime;
unsigned long lastTime;
unsigned long pulse_freq;
boolean initCard()
{
  Serial.print("Connecting to SD card... ");

  // Initialize the SD card
  if (!SD.begin(CS))
  {
    // An error occurred
    Serial.println("\nError: Could not connect to SD card!");
    Serial.println("- Is a card inserted?");
    Serial.println("- Is the card formatted as FAT16/FAT32?");
    Serial.println("- Is the CS pin correctly set?");
    Serial.println("- Is the wiring correct?");

    return false;
  }
  else
    Serial.println("Done!");

  return true;
}
void pulse () // Interrupt function

{
   pulse_freq++;
}


void setup()
{
  Serial.begin(9600);
  attachInterrupt(0, pul... Read more

Iason
#include <SPI.h>
#include <SD.h>

#define CS 8


int sensorValue = analogRead(A0);
int i = 0;
File logFile;
unsigned long currentTime;
unsigned long lastTime;
unsigned long pulse_freq;
boolean initCard()
{
  Serial.print("Connecting to SD card... ");

  // Initialize the SD card
  if (!SD.begin(CS))
  {
    // An error occurred
    Serial.println("\nError: Could not connect to SD card!");
    Serial.println("- Is a card inserted?");
    Serial.println("- Is the card formatted as FAT16/FAT32?");
    Serial.println("- Is the CS pin correctly set?");
    Serial.println("- Is the wiring correct?");

    return false;
  }
  else
    Serial.println("Done!");

  return true;
}
void pulse () // Interrupt function

{
   pulse_freq++;
}


void setup()
{
  Serial.begin(9600);
  attachInterrupt(0, pulse, RISING); // Setup Interrupt
  currentTime = millis();
  lastTime = currentTime;
  if (!initCard())
    while (1);

  // Files that are opened for writing will be
  // created automatically if they don't already
  // exist on the SD card
  logFile = SD.open("log.txt", FILE_WRITE);

  if (!logFile)
  {
    Serial.println("Could not open logfile!");
    while (1);
  }

}

void loop()
{

  
  if (i++ < 10)
  {
    

    logFile.print("[");
    logFile.print(millis());
    logFile.print("] ");
    logFile.print("Tr√ºb: ");
    logFile.println(sensorValue);
    
    

 
  }

  delay(250);
}

das hier war noch ein versuch die daten vom tr√ºbheitssenor auf die sd zu schreiben
16:12

Tue, 6 Feb

Iason
#include <Wire.h>
#include "MS5837.h"
#include <SD.h>
#include <SPI.h>

MS5837 sensor;
File myFile;
const int chipSelect = 4;
int Croissant= 0;
void setup() {
  Serial.begin(9600);
  Wire.begin();

  if (SD.begin(chipSelect)) {
    Serial.println("SD card is ready to receive data.");
    myFile = SD.open("Da.txt", FILE_WRITE);
    if (myFile) {
      myFile.println("Pressure,Temperature,Depth,Altitude");
    }
  } else {
    Serial.println("SD card initialization failed.");
  }

  while (!sensor.init()) {
    Serial.println("Init failed!");
    Serial.println("Are SDA/SCL connected correctly?");
    Serial.println("Blue Robotics Bar30: White=SDA, Green=SCL");
    Serial.println("\n\n\n");
    delay(5000);
  }

  sensor.setModel(MS5837::MS5837_30BA);
  sensor.setFluidDensity(997); // kg/m^3... Read more

Iason
#include <Wire.h>
#include "MS5837.h"
#include <SD.h>
#include <SPI.h>

MS5837 sensor;
File myFile;
const int chipSelect = 4;
int Croissant= 0;
void setup() {
  Serial.begin(9600);
  Wire.begin();

  if (SD.begin(chipSelect)) {
    Serial.println("SD card is ready to receive data.");
    myFile = SD.open("Da.txt", FILE_WRITE);
    if (myFile) {
      myFile.println("Pressure,Temperature,Depth,Altitude");
    }
  } else {
    Serial.println("SD card initialization failed.");
  }

  while (!sensor.init()) {
    Serial.println("Init failed!");
    Serial.println("Are SDA/SCL connected correctly?");
    Serial.println("Blue Robotics Bar30: White=SDA, Green=SCL");
    Serial.println("\n\n\n");
    delay(5000);
  }

  sensor.setModel(MS5837::MS5837_30BA);
  sensor.setFluidDensity(997); // kg/m^3 (freshwater, 1029 for seawater)
}

void loop() {

  Croissant += 1;
  
  sensor.read();
  myFile = SD.open("Da.txt", FILE_WRITE);
  if (myFile) {
    myFile.print(sensor.pressure());
    myFile.print(" mBar,");
    myFile.print(sensor.temperature());
    myFile.print(" ¬∞C,");
    myFile.print(sensor.depth());
    myFile.print(" Tiefe,");
    myFile.print(sensor.altitude());
    myFile.print(" m √º.NN,");
    myFile.print(Croissant);
    myFile.println("sec");
    myFile.close();
  } else {
    Serial.println("Error opening Da.txt");
  }

  Serial.print("Pressure: "); 
  Serial.print(sensor.pressure()); 
  Serial.println(" mbar");
  
  Serial.print("Temperature: "); 
  Serial.print(sensor.temperature()); 
  Serial.println(" deg C");
  
  Serial.print("Depth: "); 
  Serial.print(sensor.depth()); 
  Serial.println(" m");
  
  Serial.print("Altitude: "); 
  Serial.print(sensor.altitude()); 
  Serial.println(" m above mean sea level");

  

  delay(1000);
}

Code Druck und Temp auf SD-Karte mit Zeit in S -l√§uft
Edited9:19

Thu, 22 Feb

Iason
#include <Servo.h>

Servo AL, VRL, VRR, HRL, HRR, AR, VHR, HHR;             // Servo-Objekte f√ºr jeden ESC
int ALPin = 24, VRLPin = 25, HRLPin = 27, ARPin = 29;  // Die Pins f√ºr AL, VRL, HRL, und AR
int VHRPin = 26, HHRPin = 28;                         // Die Pins f√ºr VHR und HHR
int rcsignalPin = 5;                                 // Der Pin, an dem das RC-Signal f√ºr AL und AR angeschlossen ist
int rcsignalPin2 = 6;                               // Der Pin, an dem das RC-Signal f√ºr VHR und HHR angeschlossen ist
int rcsignalPin3 = 7;                              // Der Pin, an dem das RC-Signal f√ºr VRL angeschlossen ist
int rcsignalPin4 = 4;                             // Der Pin, an dem das RC-Signal f√ºr HRL angeschlossen ist

void setup() {
 

  // Initialisiere die Relaispins als OUTPUT... Read more

Iason
#include <Servo.h>

Servo AL, VRL, VRR, HRL, HRR, AR, VHR, HHR;             // Servo-Objekte f√ºr jeden ESC
int ALPin = 24, VRLPin = 25, HRLPin = 27, ARPin = 29;  // Die Pins f√ºr AL, VRL, HRL, und AR
int VHRPin = 26, HHRPin = 28;                         // Die Pins f√ºr VHR und HHR
int rcsignalPin = 5;                                 // Der Pin, an dem das RC-Signal f√ºr AL und AR angeschlossen ist
int rcsignalPin2 = 6;                               // Der Pin, an dem das RC-Signal f√ºr VHR und HHR angeschlossen ist
int rcsignalPin3 = 7;                              // Der Pin, an dem das RC-Signal f√ºr VRL angeschlossen ist
int rcsignalPin4 = 4;                             // Der Pin, an dem das RC-Signal f√ºr HRL angeschlossen ist

void setup() {
 

  // Initialisiere die Relaispins als OUTPUT und schalte sie aus
  pinMode(14, OUTPUT);
  pinMode(15, OUTPUT);       // Auslass vorne
  pinMode(16, OUTPUT);      // Auslass Hinten
  pinMode(17, OUTPUT);     //Einlass Hinten
  pinMode(18, OUTPUT);    // Haupteinlass 
  pinMode(19, OUTPUT);   // Einlass Vorne
  pinMode(20, OUTPUT);  // Greifer ZU
  pinMode(21, OUTPUT); // Greifer AUF
   
  AL.attach(ALPin);          // ESC an Pin 24 als AL
  VRL.attach(VRLPin);       // ESC an Pin 25 als VRL
  HRL.attach(HRLPin);      // ESC an Pin 27 als HRL
  AR.attach(ARPin);       // ESC an Pin 29 als AR
  VHR.attach(VHRPin);    // ESC an Pin 26 als VHR
  HHR.attach(HHRPin);   // ESC an Pin 28 als HHR
  
 

  digitalWrite(14, HIGH); // Relais 14 ausschalten
  digitalWrite(15, HIGH); // Relais 15 ausschalten
  digitalWrite(16, HIGH); // Relais 16 ausschalten
  digitalWrite(17, HIGH); // Relais 17 ausschalten
  digitalWrite(18, HIGH); // Relais 18 ausschalten
  digitalWrite(19, HIGH); // Relais 19 ausschalten
  digitalWrite(20, HIGH); // Relais 20 ausschalten
  digitalWrite(21, HIGH); // Relais 21 ausschalten
}




void loop() {

  int rcSignal_AL_AR = pulseIn(rcsignalPin, HIGH, 25000);      // Lese das RC-Signal f√ºr AL und AR ein
  int rcSignal_VHR_HHR = pulseIn(rcsignalPin2, HIGH, 25000);  // Lese das RC-Signal f√ºr VHR und HHR ein
  int rcSignal_VRL = pulseIn(rcsignalPin3, HIGH, 25000);     // Lese das RC-Signal f√ºr VRL ein
  int rcSignal_HRL = pulseIn(rcsignalPin4, HIGH, 25000);    // Lese das RC-Signal f√ºr HRL ein

     if (rcSignal_HRL >= 600 &&  rcSignal_HRL <= 1200) {
   HRL.writeMicroseconds(1000);
  
  } else if (rcSignal_HRL > 1800) {
    HRL.writeMicroseconds(2000);
  } else {
    HRL.writeMicroseconds(1500); 
  }
  
//-----------------------------------------//-----------------------------------------//-----------------------------------------//-----------------------------------------

  // Steuere AL und AR basierend auf dem RC-Signal
  if (rcSignal_AL_AR >= 900 && rcSignal_AL_AR <= 1300) {
    AL.writeMicroseconds(1000);
    AR.writeMicroseconds(1000);
  } else if (rcSignal_AL_AR > 1800) {
    AL.writeMicroseconds(2000);
    AR.writeMicroseconds(2000);
  } else {
    AL.writeMicroseconds(1500);
    AR.writeMicroseconds(1500);
  }
  
  // Steuere VHR und HHR basierend auf dem RC-Signal
  if (rcSignal_VHR_HHR < 1200) {
    VHR.writeMicroseconds(1000);
    HHR.writeMicroseconds(1000);
  } else if (rcSignal_VHR_HHR > 1700) {
    VHR.writeMicroseconds(2000);
    HHR.writeMicroseconds(2000);
  } else {
    VHR.writeMicroseconds(1500);
    HHR.writeMicroseconds(1500);
  }
 //-----------------------------------------//-----------------------------------------//-----------------------------------------//-----------------------------------------

   if (rcSignal_VRL >= 600 && rcSignal_VRL <= 1200) {
   VRL.writeMicroseconds(1000);
  
  } else if (rcSignal_VRL > 1700) {
    VRL.writeMicroseconds(2000);
  } else {
    VRL.writeMicroseconds(1500); 
  }

//-----------------------------------------//-----------------------------------------//-----------------------------------------//-----------------------------------------

 int pulsewidths[6];

  pulsewidths[4] = pulseIn(8, HIGH); // Equipment 
  pulsewidths[5] = pulseIn(9, HIGH); // Tauchzellen
 

  int EquipmentValue = pulsewidths[4];
  int TauchzellenValue = pulsewidths[5];

     if (TauchzellenValue >= 700 && TauchzellenValue <= 1200) {
          digitalWrite(15, LOW); // Relais 15 einschalten Auslass Ventil Vorne
          digitalWrite(16, LOW); // Relais 16 einschalten Auslass Ventil hinten
    
          } else if (TauchzellenValue >= 1400 && TauchzellenValue <= 1600) {
          // Alle Relais zwischen 14 und 20 ausschalten
          for (int i = 14; i <= 19; i++) {
          digitalWrite(i, HIGH);
          }
          } else if (TauchzellenValue >= 1750 && TauchzellenValue <= 2000) {
          digitalWrite(17, LOW); // Relais 17 einschalten Einlass Ventil hinten 
          digitalWrite(18, LOW); // Relais 18 einschalten Haupteinlass 
          digitalWrite(19, LOW); // Relais 19 einschalten Einlass Ventil vorne
    
           } else {
           // Alle Relais ausschalten, da die Pulsbreite von Kanal 6 nicht in den definierten Bereichen liegt
             for (int i = 14; i <= 19; i++) {
           digitalWrite(i, HIGH);
            }
             }

            if (EquipmentValue >= 1000  ) {
             digitalWrite(20, LOW); // Relais 20 einschalten  Equipment 
             digitalWrite(21, HIGH); // Relais 21 einschalten  Equipment 
              digitalWrite(18, LOW); // Relais 18 einschalten Haupteinlass 
             } else {
             digitalWrite(20, HIGH); // Relais 20 ausschalten Equipment 
             digitalWrite(21, LOW); // Relais 21 ausschalten Equipment
             digitalWrite(18, LOW); // Relais 18 einschalten Haupteinlass  
       }


  delay(1000 ); //nicht unter 1000 sonst laufen die motoren unkontroliert

}

Code Steuerung
22:23

Sat, 2 Mar

Iason
Hey, Wir haben das  Mobilfunkmodul Sim900a jetzt leider nicht zum laufen gekriegt- daher noch das sim900 nachbestellt- das kann man dann ab n√§chstem Mittwoch testen. Leider sind wir damit dann schon wieder 3 Euro √ºber dem Budget (also dem Geld vom Antrag f√ºrs n√§chste Wettbewerbsjahr) weshalb das dann auch die letzte Investition war es sei denn Herr Mai sichert uns n√§chste Woche nochmal was zu oder es gibt ein gro√ües Problem.

Von den 433mhz modulen h√§tten wir sonst aber auch auf jeden fall genug √ºbrig sollte das mit dem SIMzeug gar nicht hinhauen
9:49

Iason
Hey, Wir haben das  Mobilfunkmodul Sim900a jetzt leider nicht zum laufen gekriegt- daher noch das sim900 nachbestellt- das kann man dann ab n√§chstem Mittwoch testen. Leider sind wir damit dann schon wieder 3 Euro √ºber dem Budget (also dem Geld vom Antrag f√ºrs n√§chste Wettbewerbsjahr) weshalb das dann auch die letzte Investition war es sei denn Herr Mai sichert uns n√§chste Woche nochmal was zu oder es gibt ein gro√ües Problem.

ist das ein oberlimit ?
22:16

Iason
Ja also wir haben in den letzten Jahren immer "nur" 500 Euro bekommen- daher wird das diesmal auch nicht mehr sein. Ich hoffe eh dass immerhin das gedeckt wird, da ich ja alles bereits Privat bezahlt habe- der Antrag ist noch gar nicht gestellt aber ich gehe ziemlich sicher davon aus das wir die 500 Euro wieder bekommen. Aber alles was dr√ºber geht m√ºssen wir dann halt wirklich selber zahlen, da wir bisher keine Sponsoren gefunden haben. Ab Juli k√∂nnte man dann auch noch einen neuen Antrag im Sch√ºler Programm der DPG machen- da kriege ich grade f√ºr die Entwicklung eines Raketentriebwerk fast 5000 Euro- aber mal schauen

Wir brauchen ja sonst ansich akut auch keine weiteren Sensoren oder anderes insofern w√§re das schlimmstequasi wenn man doch die 433mhz variante umsetzen m√ºsste aber das ist ja auch kein unl√∂sbares Problem
22:24

ah ok, ich dachte das ist wettbewerbsrelevant. also am geld solls nicht scheitern
22:27

Iason
ja also es g√§be halt noch ein besseres simmodul f√ºr nochmal 100 - w√§re halt besser als mit den 433mhz, falls auch das Sim900 modul nicht funktioniert

Also halt einfacher und mehr M√∂glichkeiten letztlich als mit den 433mhz Sets

Ich frage Herrn Mai da am Montag oder Dienstag nochmal ob er da noch irgendwo mittel frei machen k√∂nnte - auch f√ºr nach den Wettbewerb wenn es mit dem Sim-Modul schon klappen w√ºrde
22:31

Sun, 3 Mar

Iason
#include <Servo.h>
#include <Wire.h>
#include "MS5837.h"

MS5837 sensor;

Servo AL, VRL, VRR, HRL, HRR, AR, VHR, HHR;             // Servo-Objekte f√ºr jeden ESC
int ALPin = 24, VRLPin = 25, HRLPin = 27, ARPin = 29;  // Die Pins f√ºr AL, VRL, HRL, und AR
int VHRPin = 26, HHRPin = 28;                         // Die Pins f√ºr VHR und HHR
int rcsignalPin = 5;                                 // Der Pin, an dem das RC-Signal f√ºr AL und AR angeschlossen ist
int rcsignalPin2 = 6;                               // Der Pin, an dem das RC-Signal f√ºr VHR und HHR angeschlossen ist
int rcsignalPin3 = 7;                              // Der Pin, an dem das RC-Signal f√ºr VRL angeschlossen ist
int rcsignalPin4 = 4;                             // Der Pin, an dem das RC-Signal f√ºr HRL angeschlossen ist


void se... Read more

Iason
#include <Servo.h>
#include <Wire.h>
#include "MS5837.h"

MS5837 sensor;

Servo AL, VRL, VRR, HRL, HRR, AR, VHR, HHR;             // Servo-Objekte f√ºr jeden ESC
int ALPin = 24, VRLPin = 25, HRLPin = 27, ARPin = 29;  // Die Pins f√ºr AL, VRL, HRL, und AR
int VHRPin = 26, HHRPin = 28;                         // Die Pins f√ºr VHR und HHR
int rcsignalPin = 5;                                 // Der Pin, an dem das RC-Signal f√ºr AL und AR angeschlossen ist
int rcsignalPin2 = 6;                               // Der Pin, an dem das RC-Signal f√ºr VHR und HHR angeschlossen ist
int rcsignalPin3 = 7;                              // Der Pin, an dem das RC-Signal f√ºr VRL angeschlossen ist
int rcsignalPin4 = 4;                             // Der Pin, an dem das RC-Signal f√ºr HRL angeschlossen ist


void setup() {
 

  // Initialisiere die Relaispins als OUTPUT und schalte sie aus
  pinMode(14, OUTPUT);
  pinMode(15, OUTPUT);       // Auslass vorne
  pinMode(16, OUTPUT);      // Auslass Hinten
  pinMode(17, OUTPUT);     //Einlass Hinten
  pinMode(18, OUTPUT);    // Haupteinlass 
  pinMode(19, OUTPUT);   // Einlass Vorne
  pinMode(20, OUTPUT);  // Greifer ZU
  pinMode(21, OUTPUT); // Greifer AUF
   
  AL.attach(ALPin);          // ESC an Pin 24 als AL
  VRL.attach(VRLPin);       // ESC an Pin 25 als VRL
  HRL.attach(HRLPin);      // ESC an Pin 27 als HRL
  AR.attach(ARPin);       // ESC an Pin 29 als AR
  VHR.attach(VHRPin);    // ESC an Pin 26 als VHR
  HHR.attach(HHRPin);   // ESC an Pin 28 als HHR

    Serial.begin(9600);
  Serial.println("Starting");
  Wire.begin();

  while (!sensor.init()) {
    Serial.println("Init failed!");
    Serial.println("Are SDA/SCL connected correctly?");
    Serial.println("Blue Robotics Bar30: White=SDA, Green=SCL");
    Serial.println("\n\n\n");
    }

   sensor.setFluidDensity(997); // kg/m^3 (freshwater, 1029 for seawater)
  
 

  digitalWrite(14, HIGH); // Relais 14 ausschalten
  digitalWrite(15, HIGH); // Relais 15 ausschalten
  digitalWrite(16, HIGH); // Relais 16 ausschalten
  digitalWrite(

Da w√§re jetzt mal mein Ansatz f√ºr das Unterst√ºtzungssystem zum Halten der H√∂he drin - kompilieren tuts aber getestet ist es noch nicht- wird aber ohne Tauchen beiden genauen Druckwerten auch nicht m√∂glich sein

Hatte auch noch √ºberlegt, dass man, wenn die H√∂he sehr stark abweicht noch die Tauchzellen mit bef√ºllt bzw. entleert um noch nen st√§rkeren Effekt zu haben wenn die Motoren es alleine nicht mehr packen

Das w√§ren die speziellen Stellen im Code
18:00

Wed, 6 Mar

Toni Smolka
Erste Nachricht mit dem simmodul √ºbertragen! Es ist kompliziert aber m√∂glich‚Ä¶
19:29

Iason
In-Depth: Send Receive SMS & Call with SIM900 GSM Shield & Arduino
Learn about SIM900 GSM GPRS Shield along with its Pinout, Antenna & Power Supply Selection, Wiring, AT Commands & Code for Sending & Receiving Call & SMS.
lastminuteengineers.com
15 Nov 2018

https://lastminuteengineers.com/sim900-gsm-shield-arduino-tutorial/

https://randomnerdtutorials.com/sim900-gsm-gprs-shield-arduino/
19:31

Thu, 7 Mar

The group call has ended ¬∑ 20:33

Yesterday

The group call has ended ¬∑ 21:32

The group call has ended ¬∑ 19:56

Iason
https://github.com/RDjarbeng/HTTP-GET-POST-Request-with-GSM
21:15

Today

Iason
Wir haben gestern noch ne spannende l√∂sung auch mit extra server direkt gefunden aber am Ende hat ds Modulwieder gemeint, dass es nicht ins netz kommt, was nicht stimmt denn am handy kommt es mit nur 2G auch ins Netz aber ich vermute dass es einfach zu lang braucht um die daten zu bekommen da die√ºbertragungsrate mit 0.05mbit halt wirklich ein witz ist- sollte f√ºr ne √ºbertragung der daten mit 40000 bit/s dann ansich trotzdem hinhauen aber es muss erstmal die verbindung aufbauen und die hat glaube ich ein zeitlimit f√ºrs verbinden und den erten ping drin

9:16

Iason
10:59

1 Unread Message
Iason
#include <Servo.h>
#include <Wire.h>
#include "MS5837.h"

MS5837 sensor;

Servo AL, VRL, VRR, HRL, HRR, AR, VHR, HHR;             // Servo-Objekte f√ºr jeden ESC
int ALPin = 24, VRLPin = 25, HRLPin = 27, ARPin = 29;  // Die Pins f√ºr AL, VRL, HRL, und AR
int VHRPin = 26, HHRPin = 28;                         // Die Pins f√ºr VHR und HHR
int rcsignalPin = 5;                                 // Der Pin, an dem das RC-Signal f√ºr AL und AR angeschlossen ist
int rcsignalPin2 = 6;                               // Der Pin, an dem das RC-Signal f√ºr VHR und HHR angeschlossen ist
int rcsignalPin3 = 7;                              // Der Pin, an dem das RC-Signal f√ºr VRL angeschlossen ist
int rcsignalPin4 = 4;                             // Der Pin, an dem das RC-Signal f√ºr HRL angeschlossen ist


void setup() {
 

  // Initialisiere die Relaispins als OUTPUT und schalte sie aus
  pinMode(14, OUTPUT);
  pinMode(15, OUTPUT);         // Auslass vorne
  pinMode(16, OUTPUT);        // Auslass Hinten
  pinMode(17, OUTPUT);       //Einlass Hinten
  pinMode(18, OUTPUT);      // Haupteinlass 
  pinMode(19, OUTPUT);     // Einlass Vorne
  pinMode(10, OUTPUT);    // Greifer ZU
  pinMode(11, OUTPUT);   // Greifer AUF
   
  AL.attach(ALPin);          // ESC an Pin 24 als AL
  VRL.attach(VRLPin);       // ESC an Pin 25 als VRL
  HRL.attach(HRLPin);      // ESC an Pin 27 als HRL
  AR.attach(ARPin);       // ESC an Pin 29 als AR
  VHR.attach(VHRPin);    // ESC an Pin 26 als VHR
  HHR.attach(HHRPin);   // ESC an Pin 28 als HHR

    Serial.begin(9600);
  Serial.println("Starting");
  Wire.begin();

  while (!sensor.init()) {
    Serial.println("Init failed!");
    Serial.println("Are SDA/SCL connected correctly?");
    Serial.println("Blue Robotics Bar30: White=SDA, Green=SCL");
    Serial.println("\n\n\n");
    }

   sensor.setFluidDensity(997); // kg/m^3 (freshwater, 1029 for seawater)
  
 

  digitalWrite(14, HIGH);            // Relais 14 ausschalten
  digitalWrite(15, HIGH);           // Relais 15 ausschalten
  digitalWrite(16, HIGH);          // Relais 16 ausschalten
  digitalWrite(17, HIGH);         // Relais 17 ausschalten
  digitalWrite(18, HIGH);        // Relais 18 ausschalten
  digitalWrite(19, HIGH);       // Relais 19 ausschalten
  digitalWrite(10, HIGH);      // Relais 20 ausschalten
  digitalWrite(11, HIGH);     // Relais 21 ausschalten
}




void loop() {

  int rcSignal_AL_AR = pulseIn(rcsignalPin, HIGH, 25000);      // Lese das RC-Signal f√ºr AL und AR ein
  int rcSignal_VHR_HHR = pulseIn(rcsignalPin2, HIGH, 25000);  // Lese das RC-Signal f√ºr VHR und HHR ein
  int rcSignal_VRL = pulseIn(rcsignalPin3, HIGH, 25000);     // Lese das RC-Signal f√ºr VRL ein
  int rcSignal_HRL = pulseIn(rcsignalPin4, HIGH, 25000);    // Lese das RC-Signal f√ºr HRL ein
  int LPV;                                                  // abgespeicherter Druckwert, wenn die H√∂hensteuerung zuletzt bet√§tigt wurde
  int differenzkleinAssistenz = 0.5 ;    // legt fest ab welcher differenz die hhr und vhr motoren angeschalten werden
  int differenzgrossAssistenz = 1;       // legt fest ab welcher differenz die tauchzellen angeschalten werden - gross mit zwei s geschrieben da scharfes s nicht kompiliert 

  sensor.read();


  if( rcSignal_VHR_HHR < 1200 && -1.25  > (sensor.depth())  ||  rcSignal_VHR_HHR > 1700  && -1  > (sensor.depth()) ){ // Wenn RC-Signal aktiv hoch oder runter  und Uboot mehr als 1 Meter Unterwasser 

LPV = (sensor.depth()) ;                // sichere den aktuellen Druckwert als LPV (Last Pressure Value)
    }
  

     if (rcSignal_HRL >= 600 &&  rcSignal_HRL <= 1200) {
   HRL.writeMicroseconds(1000);
  
  } else if (rcSignal_HRL > 1800) {
    HRL.writeMicroseconds(2000);
  } else {
    HRL.writeMicroseconds(1500); 
  }
  
  
  if (rcSignal_AL_AR >= 900 && rcSignal... Read more
20m


